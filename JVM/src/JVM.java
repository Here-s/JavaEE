public class JVM {

    //JVM 内存是从操作系统当中申请来的，相当于租了一个房子，然后划分成不同区域
    //内存划分：程序计数器，栈，堆，方法区

    //程序计数器：内存中最小的区域，保存了下一条要执行的指令的地址在哪里
    //  正因为操作系统是以线程为单位调度执行的，每个线程都得记录自己的执行位置，
    //  程序计数器，每个线程都会有一个

    //栈：局部变量 和 方法调用信息。方法调用的时候，每次调用一个新的方法，就都涉及到
    //  “入栈”操作，每次执行完一个方法，都涉及到“出栈”操作。如果不停的调用方法，就会栈溢出
    //  栈里面的每一个参数，叫做栈帧。每个线程都有一份栈

    //堆：一个进程只有一份，多个线程共用一个堆，new 出来的对象，就是在堆中，
    //  对象的成员变量也就在堆中了

    //局部变量在栈上，成员变量和 new 的对象在堆上，引用也在堆上
    // 引用在局部变量里面的话，就是在栈上

    //方法区：放的是“类对象”，Java->class（二进制字节码）  .class 会被加载到内存中
    // 也就被 JVM 构成了类对象，这样的类对象就放到了方法区，类对象就描述了类长啥样
    // 描述类名字是啥，里面有哪些成员，有哪些方法，每个成员的名字和类型等等
    // 方法区里面还放着 static 修饰的成员（类属性），普通的成员就是“实例属性”


    //类加载：是设计的一个 运行时环境 的一个重要的核心的功能。类加载就是把 .class 文件加载到内存中
    // 构建成类对象。主要有三个部分：loading、linking、initializing
    //loading 环节：先找到对应的 .class 文件，然后打开并读取 .class 文件，
    // 同时初步生成一个 类对象，loading 中的一个关键环节 .class 文件会把读取并解析到的信息，
    // 初步填到类对象里面。
    //linking 环节：一般是建立好多个实体之间的联系。里面的
    //  Verification 是校验的过程，主要是验证读到的内容是不是和 规范中 规定的格式完全匹配，
    //  如果不规范就会类加载失败，并且抛出异常
    //  Preparation：给静态变量分配内存，并且设置上 0 值
    //  Resolution：根据编号找到对应的内容，并且填充到类对象中
    //initializing：真正对类对象进行初始化，尤其是针对静态成员

    //方法调用题，就是类文件里面创建两个 class 类，第二个 class 类继承自第二个 class，
    //然后类文件 继承 第二个 class，类文件里面，调用两次类文件。
    // 大概原则：
    // 1.类加载阶段会进行 静态代码块 的执行，想要创建实例，势必要先进行类加载。
    // 2.静态代码块只是在类加载阶段执行一次。
    // 3.构造方法和构造代码块，每次实例化都会执行，构造代码块在构造方法前面。


    //双亲委派模型（重要）：是 类加载 中的一个环节，描述的是 JVM 中的 类加载器，如何根据类的全限定名
    // （java.lang.String）找到 .class 文件的过程。默认的类加载器：
    // BootStrapClassLoader：负责加载标准库中的类（String，ArrayList，Random，Scanner）
    // ExtensionClassLoader：负责加载 JDK 扩展的类（现在很少用）
    // ApplicationClassLoader：负责家长当前项目目录中的类
    //程序员也可以自定义类加载器，来加载其他目录中的类，Tomcat 就自定义了类加载器，加载 webapps
    // 里面的 .class 文件
    //双亲委派模型，就描述了找目录过程中，也就是上面那三个类加载器是如何配合的

    //1、考虑，加载 java.lang.String
    // 1.程序启动，先进入 ApplicationClassLoader 类加载器
    // 2.ApplicationClassLoader 会检查它的父加载器是否已经加载过了，如果没有，就调用父加载器
    //   ExtensionClassLoader
    // 3.ExtensionClassLoader 也会检查下，他的父加载器是否加载过了，如果没有，就调用父加载器
    //   BootStrapClassLoader
    // 4.BootStrapClassLoader 也会检查它的父加载器是否加载，自己没有父亲，于是自己扫描自己负责的目录
    // 5.java.lang.String 这个类在标准库中能找到，直接由 BootStrapClassLoader 负责后续的加载过程
    //   查找环节就结束了

    //2、考虑加载自己写的类
    // 1.程序启动，先进入 ApplicationClassLoader 类加载器
    // 2.ApplicationClassLoader 会检查它的父加载器是否已经加载过了，如果没有，就调用父加载器
    //   ExtensionClassLoader
    // 3.ExtensionClassLoader 也会检查下，他的父加载器是否加载过了，如果没有，就调用父加载器
    //   BootStrapClassLoader
    // 4.BootStrapClassLoader 也会检查它的父加载器是否加载，自己没有父亲，于是自己扫描自己负责的目录
    //   没扫描到，于是回到子加载器继续扫描
    // 5.ExtensionClassLoader 也扫描自己负责的目录，也没扫描到，回到子加载器继续扫描
    // 6.ApplicationClassLoader 也扫描自己负责的目录，能找到 Test 类，于是进行后续加载，查找目录的环节结束
    // 最终 ApplicationClassLoader 也找不到，就会抛出 ClassNotFoundException 异常

    //JVM 这样设计的原因是：一旦程序员自己写的类，和标准库中的类，全限定类目重复了，也能够顺利加载到标准库当中的类
    //如果是自定义类加载器，不一定遵守双亲委派模型，像 tomcat 加载 webapp 中的类，就没有遵守，因为遵守了也没意义

    //JVM 垃圾回收机制（GC）：写代码的时候，会申请内存。申请内存的时候一般是明确的，需要保存哪些数据就需要申请内存
    // 而释放内存的时候，就不明确了。代码里创建一个变量（申请一个内存），这个变量啥时候不再使用了，也不容易确定
    // 如果内存是否的时机有问题，程序就出 bug 了。如果释放迟了，其它程序就无法使用当前资源。
    // 所以内存释放既不能晚了，也不能早了。
    // 垃圾回收机制的好处就是可以防止内存泄漏。
    // 垃圾回收机制坏处：1、会消耗额外的开销 2、可能会影响程序的流畅运行（经常会引入 STW 问题，就是时间静止）
    //垃圾回收回收的是：堆（主要），方法区（类对象，进行类卸载的时候，就需要释放内存，频率极低）
    //堆：分为“正在使用的内存”  “不再使用，但是未回收的内存”  “未分配的内存”
    // 不再使用的内存部分，全部释放。对于一部分在使用内存，一部分不使用内存的对象，不释放内存。
    // 垃圾回收的基本单位是对象，不是字节。GC 会调高程序员的开发效率，降低程序的运行效率。

    //GC 的具体过程：
    // 第一阶段：找垃圾，判定垃圾：
    //  1.基于引用计数（不是 Java 采取的方案）：针对每个对象，都会额外引入一小块内存，
    //   保存这个对象有多少个引用指向它。引用计数为 0 的时候，就不再使用了，就开始回收。
    //   通过引用来决定对象的生死。引用计数，简单可靠高效。
    //    缺陷：1、空间利用率比较低，每个 new 的对象都需要计数器，如果对象本身很小，那么多出的计算器，
    //          就相当于空间利用率浪费了一倍。
    //         2、会有 循环引用 的问题，就是对象后面跟着的引用，当变量引用为 null 的时候，对象后面的引用
    //          不是 0，所以就无法释放，也无法被其他对象访问到。
    //  2.基于可达性分析（Java 方案），就不会存在 循环引用 的内存泄露了，这个就是通过额外的线程，
    //   定期的针对整个内存空间的对象进行扫描，有一些起始位置（GCRoots），会类似于 深度优先遍历一样，
    //   把可以访问到的对象进行标记，能标记的就是可达对象，如果没标记就是不可达，就是垃圾。
    //    GCRoots 是：1、栈上的局部变量 2、常量池中的引用指向的对象 3、方法区中的家庭成员指向的对象
    //   可达性分析的优点就克服了 引用计数的两个缺点，自身的缺点就是系统开销大，遍历一次可能比较慢
    //  找垃圾核心就是：没有引用指向，就不使用了，就是垃圾。
    // 第二阶段：释放垃圾。三个基本策略：1、标记-清除    2、复制算法   3、标记-整理
    //  1、标记-清除；标记就是可达性标记，清除就是直接释放内存，释放之后的内存可能是不连续的，就是内存碎片
    //  2、复制算法：就是为了解决内存碎片，引入的复制算法。就是把申请的内存一分为二，然后不是垃圾的，
    //   拷贝到内存的另一边，然后把原来的一半内存空间整体都释放。
    //   缺点：1、内存空间利用率低   2、如果保留的对象多，要释放的对象少，此时复制开销就很大
    //  3、标记-整理：针对复制算法，再做出改进。类似于顺序表删除中间元素，有一个搬运操作，
    //   然后把搬运之后，后面剩下的内存直接释放。还是不能解决复制/搬运的开销问题
    //   所以实际当中，JVM 会把多种方案结合起来使用，就是“分代回收”，针对对象进行分类，一个对象
    //   经过一轮 GC 的扫描，就“长了一岁”，针对不同的对象，采取不同的方案。
    //   一块内存，分为两半，一半放“新生代”，一半放“老年代”，然后新生代里面又有伊甸区和两个幸存区。
    //   伊甸区比幸存区大，两个幸存区一样大，刚创建出来的时候，就放在伊甸区，如果伊甸区的对象熬过
    //   一轮GC扫描，就会被拷贝到 幸存区（应用了复制算法），在后续的几轮 GC 中，幸存区的对象在
    //   两个幸存区之间来回拷贝（复制算法），每一轮都会淘汰掉一波幸存者。在持续若干了之后，对象
    //   就进入老年代，一个对象越老，继续存活的可能性就越大，所以老年代的扫描频率大大低于新生代
    //   老年代中使用标记整理的方式进行回收。
    //   分代回收的过程，类似于找工作的过程。
    //   分代回收中，还有一个特殊情况，有一类对象可以直接进入老年代（大对象，占有内存多的对象）
    //   大对象拷贝开销比较大，不适合使用复制算法，所以直接进入老年代。
    //重点掌握垃圾回收算法（引用计数，可达性分析，标记清除，标记整理，复制算法，分代回收）
    //JVM 当中，实现上面这些算法的模块叫做：垃圾回收器
}
