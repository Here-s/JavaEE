public class Test5 {

    //多线程下使用 哈希表
    //HashMap 本身不安全。
    //1、HashTable 不推荐：保证线程安全，就是给关键方法加锁，针对 this 来加锁，
    // 当有多个线程来访问这个 HashTable 的时候，无论是啥样的操作，都会引起锁竞争，从而导致效率变低。
    //2、ConcurrentHashMap（给每个链表的头加锁） 推荐这个：就可以解决上述问题。操作元素的时候，
    // 是针对这个元素所在的链表的头节点来加锁的，如果两个线程的操作是针对两个不同的链表上的元素，
    // 没有线程安全问题，就不必加锁
    // 由于 hash 表中，链表的枢密院非常多，每个链表的长度是相对短的，因此就可以保证锁冲突的概率就非常小了。
    //ConcurrentHashMap 减少了锁冲突，就让锁加到每个链表的头节点上面（锁桶）
    //ConcurrentHashMap 只是针对写操作加锁了，读操作没加锁，只是使用
    //ConcurrentHashMap 更广泛的使用了 CAS 进一步提高效率（比如维护 size 操作）。
    //ConcurrentHashMap 针对扩容，进行了巧妙的化整为零，如果元素多了，链表就会长，就会影响 hash 表的效率
    // 就需要扩容（增加数组的长度），扩容就需要创建一个更大的数组，然后把之间旧的元素都给搬运过去（非常耗时）
    // 对于 HashTable 来说，只要你这次 put 触发了扩容就一口气搬完，会导致这次 put 非常卡顿。
    // 对于 ConcurrentHashMap 来说，每次操作只搬运一点点，通过多次操作来完成搬运的过程。
    // 同时维护一个新的 HashMap 和一个旧的，查找的时候即需要查旧的，也需要查新的，插入的时候只插入新的。
    // 直到搬运完毕再销毁旧的。
}
