import java.util.concurrent.atomic.AtomicInteger;

public class Test1 {




    //面试系列：八股文
    //一、常见的锁策略：
    // 锁策略：和实现锁的人有关系
    // 1、悲观锁和乐观锁：
    //  悲观锁：预期锁冲突的概率很高。做的工作更多，付出的成本更多，更低效
    //  乐观锁：预期锁冲突的概率很低。做的工作更少，付出的成本更低，更高效
    // 2、读写锁 vs 普通的互斥锁
    //  对于普通的互斥锁，只有两个操作：加锁，解锁。只要两个线程针对同一个对象加锁，就会产生互斥。
    //  对于读写锁来说，分成了三个操作：
    //      加读锁：如果代码只是进行了读操作，就加读锁。 读锁和读锁之间不存在互斥关系的。
    //      加写锁：如果代码中进行了修改操作，就加写锁。 读锁和写锁之间，写锁和写锁之间，需要互斥操作
    //      解锁
    //      多线程同时读同一个变量，不会有线程安全问题。很多场景当中，都是读多写少
    // 3、重量级锁 vs 轻量级锁     和上面的 悲观乐观 有一定重叠。可以认为：悲观锁是重量级锁，乐观锁是轻量级锁。
    //  重量级锁：就是做了更多的事情，开销更大。一般来说调用系统接口的就认为是重量级锁
    //  轻量级锁：做的事情更少，开销更少。一般认为是纯用户态实现的锁就是轻量级锁。
    // 4、挂起等待锁 vs 自旋锁
    //  挂起等待锁：通过内核的一些机制来实现，往往较重，重量级锁的一种典型实现。
    //  自旋锁：通过用户态代码来实现，往往较轻，轻量级锁的一种典型实现。也就是盲等。
    // 5、公平锁 vs 非公平锁
    //  公平锁：多个线程在等待一把锁的时候，谁是先来的，谁就能先获取到这个锁（先来后到）
    //  非公平锁：多个线程在等待一把锁的时候，不遵守先来后到。不遵守先来后到，每个线程拿到锁的概率都是一样的。
    //  要想实现公平锁，就得付出更多的代价（让整个线程来排队进行先来后到）
    // 6、可重入锁 vs 不可重入锁
    //  一个线程，针对他一把锁，连续加两次锁，如果会死锁，九四不可重入锁，如果不会死锁，就是可重入锁。
    // 7、synchronized 即是一个乐观锁，也是一个悲观锁。不止读写锁，只是一个普通互斥锁。
    //  既是一个轻量级锁，也是一个重量级锁（根据竞争的激烈程度，自适应）非公平锁，可重入锁
    //  轻量级锁的部分基于自旋锁来实现，重量级锁的部分基于挂起锁来实现。
    //  伪代码：不是真正的代码，不能编译运行。

    // CAS （compare and swap）比较和交换，要做的事情就是拿着 寄存器/某个内存 中的值和另外一个内存的值进行比较
    //  如果值相同了，就把另外一个寄存器/内存的值，和当前这个内存进行交换。
    //  CPU 提供了一个单独的 CAS 指令，通过这一条指令，就能完成上面说的步骤。
    //  最大的意义，就是写多线程代码的时候，提供了一个新的思路和方向。就像上面那个逻辑，硬件实现了，直接使用就好了。
    //  基于 CAS 能够实现原子类，针对常用的一些 int long array 进行了封装
    public static void main(String[] args) throws InterruptedException {
        //这里创建的 num 就是原子的。
        AtomicInteger num = new AtomicInteger(0);
        Thread t1 = new Thread(()-> {
            for (int i = 0; i < 50000; i++) {
                //这个方法就相当于 num++
                num.getAndIncrement();
            }
        });
        Thread t2 = new Thread(()-> {
            for (int i = 0; i < 50000; i++) {
                //这个方法就相当于 num++
                num.getAndIncrement();
            }
        });
        //++num
        num.incrementAndGet();
        //--num
        num.decrementAndGet();
        //num--
        num.getAndDecrement();
        //+= 10
        num.getAndAdd(10);
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        //通过 get 方法得到 原子类 内部的的值。比加锁更快，因为这个不存在线程阻塞，线程安全问题。
        System.out.println(num.get());
    }
    //写多线程代码的时候，要时刻惦记着，任意两个代码之间，都可能被其他线程插入执行一些逻辑。

    //面试中，面试官关于 CAS 主要问的问题：如何理解 CAS 中的 ABA 问题？
    // CAS 中的关键，是先比较，再交换。比较其实是在比较当前值和旧制是不是相同。
    // 把这两个值相同，就视为是中间没有发生过改变。这里的前值和旧值肯被修改过，也可能没有修改过。
    // 解决这样的问题，就是引入版本号。在比较的时候，就看版本号一样不一样，如果一样的话，就说明没变，反之就变了

    //基于版本号的方式来进行多线程控制工具，也是一种乐观锁的典型实现。
    // 1、数据库里使用
    // 2、版本管理工具（SVN，Git）

    // REP 系统，历史悠久，未来也会持续去用的软件。应对的应用场景非常复杂，这样的系统本身也是非常复杂。
    //  SAP 公司生产 ERP 很强，然后是 Oracle 公司。



    //通过 线程池和协程 来进一步加快速度：
    // Runnable 描述一个任务
    // 阻塞队列组织若干任务
    // 创建一个 worker 类，描述一个工作线程，完成的任务就是从阻塞队列中获取元素，并执行任务
    // 创建一个 List 来组织若干个线程对象。
    // 实现一个 submit 方法，把任务给提交到队列当中。

    //多个线程尝试对同一个对象加锁的时候 才会出现锁竞争，才会出现阻塞等待，
    // 多个线程在针对不同的对象加锁，多个线程在针对不同的对象加锁，此时就不会设计阻塞等待

    //实际开发当中，可能有很多很多线程，有些线程之间，是需要互斥的，有些之间是不需要互斥的
    // 哪些线程在针对同一个对象加锁，就是有互斥关系。没有针对同一个对象加锁，就没有互斥关系。
    //锁对象出了能体现到互斥的效果，同时还能体现到：等待-通知 这样的效果。一个代码里面，可能有很多很多线程

}
