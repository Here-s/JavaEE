public class Test3 {

    //TCP/IP 五层协议线：应用层，传输层，网络层，数据链路层，物理层
    // 应用层：最重要的一层，需要自己去实现，就是：设计并实现一个应用层协议（比较简单，也是工作最经常做的）
    //  前端和后端就是通过网络来进行交互的，交互的过程中，就需要约定好：前端发啥样的数据，后端回对应的数据
    //  设计一个应用层协议，主要就是包含两个工作：1、明确传输的信息，明确数据的组织格式
    //  需要前后端配合的话，就需要设置一个 应用层协议。应用层协议可以随心所欲去设计，我们就可以直接去套用
    //  一些流行的模板：
    //   xml 可读性好，但是运行效率不高 属于老的数据格式了。虽然也在用，但是用的越来越少了
    //      特点：由标签构成： <标签名>内容</标签名> 标签名就是 key，标签值就是 value 通过标签就更好的提升了可读性
    //      虽然提高了可读性，但是又引入了太多的辅助信息（标签名之类的） 就导致占用了更高的 网络带宽
    //      所以 xml 就很少作为 应用层协议的 模板了，更多的是用来做一些配置文件
    //   json  可读性好，但是运行效率不高。当下最流行的一种设计 应用层协议 的数据格式，通过 大括号 构成了键值对格式
    //      一个 大括号 中有很多键值对，键值对之间使用 逗号 分割，键 和 值 之间使用 冒号 分割。
    //      要求 键 必须是字符串类型的 值允许有好多种（数字，字符串，布尔，数组，另一个 json）
    //      json 中表示字符串，单引号和双引号都可以，最后一个键值对，后面可以有逗号，也可以没有（标准要求是没有的，
    //      但是一般的 json 解释器都不会在意），json 要求 key 一定是字符串，因此 key 这里的引号可以忽略，
    //      除非 key 中包含了一些特殊符号（比如像 空格，-，就不能省略了）
    //      相比于 xml 来说，json 也能保证可读性，同时又没有那么繁琐（占用的带宽小）
    //      json 虽然传输效率比 xml 高，但是然然要多传递一些冗余信息，就是 key 的名字，尤其是数组的时候，更明显
    //      当表示数组的时候，就会有很多 key 重复出现，也就占用了带宽。出问题的请求和响应，一目了然
    //   protobuffer  这个的运行效率高，但是可读性不高。是一种 二进制格式 的数据，在 protobuffer 的数据中
    //      不再包含上面 key 的名字了，而是通过顺序以及一些特殊符号，来区分每个字段的含义。同时再通过一个 LDL 文件
    //      来描述这个数据格式（每个部分是啥意思） LDL 只是起到一个辅助开发的作用，并不会真正的进行传输，
    //      传输的只是二进制的纯粹的数据
    //最知名的应用层协议：HTTP

    //设计应用层协议 是一件非常普遍的事情，也是一件并不复杂的事情：
    //设计应用层协议，要做的工作：
    // 1，明确传输的信息（根据需求）
    // 2、明确传输的格式（参考现有目标）
    // 有一些现成的，已经被设计好的被广泛使用的应用层协议（很多时候可以根据现成的协议，稍加修改，或者稍加扩充，二次开发）

    //传输层：虽然是操作系统内核实现，但是仍然有很大意义，进行网络编程都要用到 socket ，一旦你调用了 socket，
    // 代码就进入传输层的范畴。如果代码出现 bug，就需要传输层的知识了，TCP 协议考的很多。
    //端口号：0-65535 之间的整数
    //知名端口号：把 0-1024 这些端口号，给划分除了一些具体的作用，并不是强制要求，而是建议

    //传输层常见的协议有很多：UDP 和 TCP
    // UDP：学习一个协议，很多时候就是在研究报文格式。数据报的内容：UDP 报头，UDP 数据载荷（完整的应用层数据）
    // 代码中写的端口号，就会被打包到 UDP 数据报中。报文长度是 2 个字节，0-64k 在现代互联网当中，就可能不够用了
    // 数据大的话，就会进行拆包，然后分为多个发送，接收方再重新拼接起来，但是可能回出现丢包和乱序，所以就改成 TCP 来解决
    // 因为 TCP 没有大小限制
    // 校验和：就是用来验证网络传输的这个数据是否正确，因为网络传递的本质就是：光信号和电信号，但是外界的磁场之类的会影响到
    // 可能就导致 0 变成 1，就导致数据出错了，所以校验和就能帮助我们发现数据中的错误。还可以使用数据内容参与运算，
    // 如果是基于数据内容得到的校验和，那么数据出错的话，被识别出来的概率还是很高的。这里的 校验和 与 以太网 的校验和一样

    // TCP：也有需要记得端口号    TCP 的报头是变长的，不像 UDP 是固定的 8 字节。TCP 会有保留位：就是为了以后的升级留点空间
    //  TCP 报文的核心段：URG ACK PSH RST SYN FIN

    //传输层：
    //UDP：报文长度是 2 个字节，一个 UDP 报文最多是 65535 =》 64k
    //    通过校验和可以判断是否正确

    //TCP：是一个非常非常重要的协议，不光在实际开发中广泛使用，而且也是面试常考的。
    // 有连接，可靠传输，面向字节流，全双工。
    //可靠传输：是 TCP 的核心机制。引入 TCP 的关键原因，就是为了保证可靠传输
    // 实现可靠传输的核心：
    // 1、确认应答：就是发出去之后，对方收到了。但是消息可能会乱序
    // 避免出现乱序，就可以根据编号机制来解决，根据编号就可以知道消息是第几条了。
    // 就是根据编号来确定当前的 应答报文 是针对哪个消息进行的确认应答
    // TCP 的针对消息的序号，还有说法，
    // 2、超时重传：相当于对确认应答进行了补充，确认应答是网络一切正常的时候，通过 ACK 通知发送方收到了
    // 如果出现了丢包的情况，超时重传机制就要起到效果了。如果网络不是有太大问题，一般重传都是可以成功的。
    //  可能是发丢了，对方直接没收到。也可能是 对方收到消息了，但是 ACK 丢了。
    //  如果是 ACK 丢了，此时触发了超时重传，就会导致接收方收到了重复的消息，这样的话，
    //  TCP 内部会有一个去重操作，接收方收到的数据会先放在操作系统的 接收缓冲区 当中的，
    //  收到新的数据，TCP 就会去 接收缓冲区 当中检查有没有这个消息，如果有，就丢弃，没有的话，就放到缓冲区
    //  用来保证程序调用 socket API 拿到的这个数据一定是不可重复的。
    //  重传如果失败，还会继续尝试，也不会无休止的重传，连续几次失败的话，就认为是网络遇到了严重的情况，
    //  再怎么重传也可能不行，就只能放弃（自动断开与 TCP 的连接）重传的时间间隔会逐渐变大。

    //基于上面两个协议，TCP 的可靠性，就得到了有效的保障
    // 3、连接管理，也是 TCP 保证可靠性的一个机制（经典面试题）网络部分最高频的面试题
    //  1）如何建立连接（三次握手）客户端和服务器之间，通过三次交互，完成了建立连接的过程
    //   如果 ACK 是 1 ，表示这个报文就是一个”确认报文段“  如果 SYN 这一位是 1 表示当前报文就是一个
    //   同步报文段，主机 A 和 主机 B 之间要建立连接。
    //   三次握手，相当于是”投石问路“，检查一下当前这个网络的情况是否满足可靠传输的基本条件
    //   让双方能够协商一些必要的信息。
    // 经典面试题：
    //  1、描述 TCP 三次握手的过程：针对这个问题，一定不要用嘴说，一定一定要画图
    //   如果是线下面试，一定一定要带上纸和笔
    //   为啥是三次：因为四次的话，分开传输会降低效率，
    // 2）如何断开连接（四次挥手）：三次握手，就让客户端和服务器之间建立好了连接，其实在建立好连接之后
    //  操作系统内核当中，就需要使用一定的数据结构来保存连接的相关的信息，保存的信息其实最重要的就是前面说的五元组
    //  有一天，连接断开了，那么五元组保存的连接信息就没意义了，对应的空间就可以释放了。
    //  双方各自向对方发送了 FIN（结束报文段）请求，并且各自给对方一个 ACK 确认报文。
    //  三次握手，一定是客户端主动发起的（主动发起的一方才叫客户端）
    //  四次挥手，可能是客户端主动发起，也可能是 服务器 主动发起的
    //  三次握手，中间两次能合并。
    //  四次挥手，中间有两次合并不了（有时候是能合并）不能合并是因为发生的 ACK 和 FIN 的时机是不同的
    //    四次挥手就是各自和对方说断开连接。
    //  三次握手中：发生的 ACK 和 SYN 是同一时机发生的，就能够合并，此处的 B 给 A 发送的 ACK 和 SYN
    //   都是操作系统内核负责的，B 给 A 发的 FIN 是用户代码负责（B 的代码中调用了 socket.close()方法，才会触发
    //
}
