public class Test1 {

    //网络的发展历史：上世纪 50-60 诞生
    //局域网：通过网线把主机连起来，就形成了局域网。更多的是通过交换机和路由器
    //比较大的局域网就可以认为是广域网

    //IP 地址：描述了网络上的一个主机的位置（收获地址）
    // IP 地址本质上是一个 32 位的整数，由于 32 位的整数，不方便人来记忆和读，
    // 一般常见的操作都是把这 32 位的整数，按照每个字节，分成四个部分，中间用 . 来分隔
    // 也就是 点分十进制
    //特殊的 IP 地址：127.0.0.1 一个特殊的 IP 地址，环回 IP，表示自己这个主机。
    //端口号：描述了一个主机上的 某个应用程序（收件人的电话）
    // 本质上是一个 2 个字节（16位）的无符号整数，3306 MySQL 默认的端口号

    //协议：非常重要，本质上就是约定，发出来的数据是啥样的格式，，接收方按照什么格式来接收。

    //网络通信的时候，本质上传输的是：光信号和电信号。通过光信号的频率（高频率/低频率）
    // 电信号的电平（高电平/低电平）来表示 0/1。这一串 0 1 的意思是
    //学习网络原理的时候，很多时候都是在研究各种协议
    //关于协议分层：网络通信这个过程，很复杂，里面有很多很多细节，如果只通过一个协议，
    // 来约定所有的细节，这个协议就会非常庞大、复杂。更好的办法就是把一个大的复杂的协议，
    // 拆成多个小的，更简单的协议，每个协议，负责一部分工作。
    // 好处：1、每层协议不需要理解其他层协议的细节（更好的做到了封装）
    //  相当于：打电话的人不需要理解电话的工作原理，就能完成打电话的操作。
    //      制造电话的人，也不需要成为语言大师
    // 好处：2、把对应层的协议替换成其他协议（更好的耦合）
    //  相当于打电话的人，可以使用有线电话，也可以使用无线电话。打电话的人，可以使用汉语，也可以使用英语

    //网络分层：OSI 七层网络模型，不叫作 ISO 真实的情况是 OSI 简化版本，就是 TCP/IP 五层（四层）模型
    // 五层模型：物理层，数据链路层（网卡层），网络层，传输层，应用层（程序员关注实现的内容）
    // 说四层的时候，就是不讨论物理层，因为 物理层 是硬件方面的。
    //物理层：网络通信中的硬件设备。
    //数据链路层：通过网线相连的设备。具体的节点和节点之间的路线和通信方式
    //网络层：负责点到点之间的通信，网络中任意节点和任意节点之间的通信。网络层负责最优路线
    //传输层：负责端到端之间的通信，起点到终点，只关注结果，不关注过程是怎么走的。
    //应用层：和应用程序密切相关的，你传输的这个数据，是干啥用的，不同的应用程序就有不同的用途

    //网络设备所在的分层：
    // 一台主机就对应了 物理层 到 应用层 五层。
    // 一台路由器主要就是 物理层 到 网络层（主要是实现了物理层，数据链路层，网络层）
    // 一台交换机主要就是 物理层 到 数据链路层（主要实现了物理层，数据链路层）

    //网络分层当中的一组重要概念：封装 和 分用[重点]。
    // 比如 QQ 程序，根据用户输入的内容，把数据构造成一个协议报文（这些协议是程序员自己设定的）
    // 应用层协议就调用操作系统提供的 API，把应用层的数据交给传输层（就进入操作系统内核了）

    //传输层（操作系统内核）
    // 根据刚才传输过来的数据，基于当前使用的传输层协议，来构造出一个传输层的协议报文。
    // 拿到数据的时候，要进行打包封装，主要就是为了可以贴上辅助转发的标签信息。然后就会把传输层的数据报交给网络层
    //网络层（操作系统内核）
    // 拿到了完整的传输层数据报，就会在根据当前使用的网络层协议（例如 IP），再次进行封装，
    // 把 TCP 数据报构造成 IP 数据报，还是添加一个协议报头。仍然是字符串拼接的过程。
    // 紧接着，当前的 网络层协议，就会把这个 IP 数据报，交给数据链路层
    //数据链路层（驱动程序）
    // 在刚才的 IP 数据报基础上，根据当前使用的数据链路层发协议，给构造成一个 数据链路层的数据报
    // 典型的数据链路层的协议，叫做”以太网“，就会构造成一个：以太网数据帧
    // 以太网数据帧：帧头 + IP 数据报 + 帧尾   帧头里面的信息是：接下来要传给的设备地址是啥
    // 随着数据往下一个设备转发，帧头中的地址一直在时刻发生改变。
    // 数据链路层，又会把这个数据交给物理层
    //物理层（硬件设备，网卡）
    // 做的工作，就是根据刚才的以太网数据帧（其实就是一组 0 1）
    // 把这里的 0 1 变成 高低电平，通过网线传输出去
    // 或者把这里的 0 1 变成 高频/低频 的电磁波，通过 光纤/无线 的方式传播出去。
    // 此时就离开主机了，前往下一个设备。下一个设备可能是 路由器/交换机/其他设备。

    //上面是封装的过程，下面是分用的过程，分用就是封装的逆过程，
    // 主机 B 的网卡感知到一组 高电平 和 低电平，然后就会把这些店铺翻译成 0 1 的一串数据
    // 然后这一串 0 1 就是一个完整的以太网数据帧。然后 物理层 就把数据交给 数据链路层
    //数据链路层：负责对这个数据进行解析，去掉帧头和帧尾，取出里面的 IP 数据报。然后交给 网络层协议
    //网络层协议（IP 协议）：又会对这个数据进行解析，去掉 IP 协议报头，取出里面的 TCP 数据报 再交给 传输层
    //传输层（操作系统内核）：又会对这个数据进行解析，去掉 TCP 报头，取出里面的 TCP 数据报，再交给应用层
    //应用层（应用程序）：就会调用 socket API 从内核中读取到这个应用层的数据报，再按照应用层协议进行解析，
    // 然后根据解析结果显示到窗口中。

    //网络编程套接字，是操作系统给应用程序提供的一组 API （socket API）
    // socket API 可以视为是 应用层 和 传输层 之间的通信桥梁。
    // 传输层的核心协议有两种，TCP UDP，socket API 也有对应的两组，
    // 由于 TCP 和 UDP 协议，差别很大，所以这两组 API 差别也挺大
    // TCP：有连接，可靠传输，面向字节流，全双工。
    // UDP：无连接，不可靠传输，面向数据报，全双工。
    // 有链接：相当于打电话，得先接通，才能交互数据。
    // 无连接：像发微信，不需要接通，直接就能发数据。
    // 可靠传输：传输过程中，发送方知道接收方有没有收到数据。就像已读
    // 不可靠传输：传输过程中，发送方不知道接收方有没有收到数据。
    // 面向字节流：以字节为单位进行传输（非常类似于 文件操作 中的字节流）
    // 面向数据报：以数据报为单位进行传输（一个数据报都会明确大小）
    //  一次发生/接收必须是一个完整的数据报，不能是半个，也不能是一个半
    // 全双工：一条链路双向通信。
    // 半双工：一条链路单向通信。
}
