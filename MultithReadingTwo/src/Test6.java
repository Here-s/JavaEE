class Counter1 {

    //连续去加两次锁。外层先加了一次锁，里层又对同一对象再加一次锁。
    //外层锁：进入方法，则开始加锁，这次能够加锁成功，因为当前锁没有人占用。
    //里层锁：进入代码块，开始加锁，这次加锁不能加锁成功，因为这个锁被外层占用了，
    // 要等到外层锁释放，里层锁才能加锁。
    //外层锁要执行完整个方法，才能释放。
    //但是要想执行完整个方法，就得让里层锁加锁成功继续往下走。所以就变成死锁了。

    //因为容易死锁，所以 JVM 的开发者，就把 synchronized 实现成了 可重入锁。
    // 对于可重入锁，上述连续加锁操作，不会导致死锁。
    //可重入锁的意义就是：降低了程序员的负担（降低了使用成本，提高了开发效率）
    // 但也带来了代价，程序中需要又更高的开销（维护锁属于哪个线程，并且加减计数，降低了运行效率）

    //死锁的其他场景：
    //1、一个线程，一把锁
    //2、两个线程，两把锁。你要锁，他也要锁，就互相要，然后就死锁了。
    //3、N 个线程，M 把锁

    //死锁的四个必要条件：避免死锁，从这 4 个条件出发。
    // 1、互斥使用：一个锁被一个锁占用之后，其他线程占用不了（锁的本质，保证原子性）
    // 2、不可抢占：一个锁被一个线程占用之后，其他线程不能把这个锁给抢走（挖墙脚不行）
    // 3、请求和保持：当一个线程占据了多把锁之后，除非四显示的释放锁，否则这些锁是在都是被该线程持有的。
    // 4、环路等待：等待关系，成环了：A 等 B，B 等 C，C 又等 A。
    //      避免环路等待：约定好，针对多把锁加锁的时候，有固定的顺序就好。
    //      所有的线程都遵守同样的规则顺序，就不会出现环路等待。

    //实际开发当中，很少出现这种一个线程需要锁里再套锁的情况，如果不嵌套锁，也就没那么容易死锁。
    public static int count;

    //这里就是锁两次：
    synchronized public void increase() {
        synchronized (this) {
            count++;
        }
    }
}

public class Test6 {

    public static void main(String[] args) {

    }
}
