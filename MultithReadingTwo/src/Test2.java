class Counter {

    //两个线程要去自增的变量
    public static int count;

    synchronized public void increase() {
        count++;
    }
}

public class Test2 {

    //线程安全，线程当中最重要，最复杂的问题。面试问道多线程，线程安全一定问到。
    //多线程，多进程是最基本的处理并发编程的任务。有很多模型：actor  csp  async+await

    //操作系统调用线程的时候，是随机的（抢占式执行），因为是抢占式的，所以可能出现 bug
    //如果调度随机性，引入了 bug，那么就认为代码线程是不安全的

    private static Counter counter = new Counter();
    public static void main(String[] args) throws InterruptedException {
        Thread t1 = new Thread(()-> {
            for (int i = 0; i < 50000; i++) {
                counter.increase();
            }
        });
        Thread t2 = new Thread(()-> {
            for (int i = 0; i < 50000; i++) {
                counter.increase();
            }
        });
        t1.start();
        t2.start();
        //因为线程调度是随机的，就不知道是 t1 和 t2 谁先结束。
        t1.join();
        t2.join();
        //在两个线程都执行完了之后，再打印 count 结果

        //运行结果不是 100000 说明出现 bug 了。两个线程同时触发自增，就只加了 1
        //count++ 其实是 三个 CPU指令：
        // 1、把内存当中的 count 值，加载到 CPU 寄存器当中
        // 2、把寄存器当中的值 + 1
        // 3、把寄存器的值写回到 内存的 count 当中。
        //因为是抢占式执行，就导致两个线程同时执行这三个指令的时候，就充满了随机性。
        //就可能出现一组先后排列的情况，也就是不能都完成加1
        //所以，如果能让 t1 先执行完，然后再让 t2 执行，就可以了。

        //这里加的结果是在 50000 - 100000 之间。因为有一部分是串行的，有一部分是交错的。

        //如何解决上述问题：加锁。通过加锁就没避免乱序执行。
        //在自增之前先加锁，自增之后解锁。解锁之后再执行另外一个线程。
        // 加锁之后，并发程度降低，数据靠谱了，但是速度慢了
        //并发性越高，速度越快，但是可能会出现一些问题。
        //实际开发当中，一个线程要做的事很多。可能只有某一个步骤有线程安全，所以只对有线程安全的加锁就好了。

        //Java 当中加锁的方式有很多种，最常用的就是：synchronized
        //加锁之后就正确了。 线程加锁成功之后，其他线程尝试加锁，就会触发阻塞等待。直到占用锁的线程解锁

        //什么样的代码会产生线程不安全。不是所有的多线程代码都要加锁。
        //产生线程不安全的原因：
        // 1、线程是抢占式执行，线程间的调度充满随机性，是线程不安全的万恶之源。
        // 2、多个线程对同一个变量进行操作。如果是多个线程针对不同的变量进行修改就没事。多个线程针对同一个变量读也没事
        // 3、针对变量的操作不是原子的，也会导致线程不安全。读操作本来就是原子的，所以不担心
        // 4、内存可见性，也会影响到线程安全。因为读内存比读寄存器很慢，
        System.out.println(counter.count);
    }
}
